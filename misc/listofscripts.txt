


____________________________________________________________________
qd [YYYY-MM-DD]		#prepara/abriar
			#si fecha no existe, crear desde template
			#si la fecha existe: pull kw a nuevo archivo
			#abre p_w_fecha y archivo.json

qd --use-kw YYYY-MM-DD  #activar keywords sin copiar/pegar
			#de p_k_fecha -> pending_k

qd --use-kw YYYY-MM-DD  #llama a OpenAI y genera keywords
			#escribe a pending_keywords.txt
			#crea un backup

q YYYY-MM-DD		#publica texto/metadatos del .txt
			#si la fecha existe, no toca keywords

q --kw YYYY-MM-DD	#publica text/metadatos y además aplica keywords desde pending_kw

q --dry-run YYYY-MM-DD  #valida y construye lo que publicaría pero no hace el commit

PE:

____________________________________________________________________
Nueva entrada (texto + keywords)

qd 2026-01-05          # creas/edita el txt
qk 2026-01-05          # genera keywords (pending_keywords.txt)
q --dry-run 2026-01-05 # verifica
q --kw 2026-01-05      # publica todo (texto + keywords)


Ediatr título (sin tocar keywords)
qd 2026-01-03          # abre txt + (si existe) workspace keywords + archivo.json
# editas textos/2026-01-03.txt
q --dry-run 2026-01-03
q 2026-01-03           # publica texto, keywords quedan iguales

Editar keywords manualmente
qd 2026-01-03                 # abre workspace por fecha
# editas scripts/pending_keywords_2026-01-03.json
qd --use-kw 2026-01-03        # activa staging global
q --dry-run 2026-01-03
q --kw 2026-01-03             # aplica keywords nuevas

Regenrar keywords por api para una entrada existente
qk 2026-01-03
# opcional: editas scripts/pending_keywords.txt
q --dry-run 2026-01-03
q --kw 2026-01-03

____________________________________________________________________
qd YYYY-MM-DD        # escribir
qk YYYY-MM-DD        # generar keywords
q --dry-run YYYY-MM-DD
q YYYY-MM-DD

qd YYYY-MM-DD        # escribir
qdk YYYY-MM-DD       # keywords + dry-run
q YYYY-MM-DD         # publicar


____________________________________________________________________
qd
qd 2026-01-01
-usa hoy si no se pasa fecha
-valida la fecha
-si el archivo no existe, crea un nuevo desde templateText.txt
-abre en subl la entrada, pending_keywords.txt, archivo.json (si la fecha ya existe)

qk
qk 2026-01-01
-opcional
-llama la api gpt
-enerea sugerencias de keywords
-sobresecribe pending_keywords.txt
-crea backup automático si ya existía
-no toca git
-no modifica archivo.json
-el human decide si las acepta, edita, o borra

q --dry-run
q --dry-run 2026-01-01
-opcional pero muy recomendado
-genera pending_entry.json
-valida el formato de fecha, la estructura del .txt, json, reglas editoriales
-detecta automáticamente nueva entrada o edición de entrada existente
-muestra mensaje de commit que se usaría
-no toca git
-no modifica archivo.json
-nada irreversible ocurre

q
q 2026-01-01
-upsert autoático en archivo.json (si la fecha no existe, crea entrada, sino edita entrada)
-añade una línea a logs/publish_log.jsonl
-commit y push a GitHub
-borra pending_entry
-no borrar pending_keywords


-____________________________________________-

python3 scripts/make_pending_entry.py textos/2025-12-25.txt

python3 scripts/merge_pending.py


abre el .txt existente (si existe) o lo crea (si no):
qd 2025-12-10 

Run first (to see that the correct files were created):
q --dry-run 2025-12-25

si la entrada existe → la reemplaza (update automático)
si no existe → la añade (new)
commit message:
Entrada 2025-12-10 — … (nuevo)
Edición 2025-12-10 — … (modificación)
al final borra scripts/pending_entry.json, pero no toca pending_keywords.txt.:
q 2025-12-10




