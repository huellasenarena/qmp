qd YYYY-MM-DD        # escribir
qk YYYY-MM-DD        # generar keywords
q --dry-run YYYY-MM-DD
q YYYY-MM-DD

qd YYYY-MM-DD        # escribir
qdk YYYY-MM-DD       # keywords + dry-run
q YYYY-MM-DD         # publicar


__________________________________-
qd
qd 2026-01-01
-usa hoy si no se pasa fecha
-valida la fecha
-si el archivo no existe, crea un nuevo desde templateText.txt
-abre en subl la entrada, pending_keywords.txt, archivo.json (si la fecha ya existe)

qk
qk 2026-01-01
-opcional
-llama la api gpt
-enerea sugerencias de keywords
-sobresecribe pending_keywords.txt
-crea backup automático si ya existía
-no toca git
-no modifica archivo.json
-el human decide si las acepta, edita, o borra

q --dry-run
q --dry-run 2026-01-01
-opcional pero muy recomendado
-genera pending_entry.json
-valida el formato de fecha, la estructura del .txt, json, reglas editoriales
-detecta automáticamente nueva entrada o edición de entrada existente
-muestra mensaje de commit que se usaría
-no toca git
-no modifica archivo.json
-nada irreversible ocurre

q
q 2026-01-01
-upsert autoático en archivo.json (si la fecha no existe, crea entrada, sino edita entrada)
-añade una línea a logs/publish_log.jsonl
-commit y push a GitHub
-borra pending_entry
-no borrar pending_keywords


-____________________________________________-

python3 scripts/make_pending_entry.py textos/2025-12-25.txt

python3 scripts/merge_pending.py


abre el .txt existente (si existe) o lo crea (si no):
qd 2025-12-10 

Run first (to see that the correct files were created):
q --dry-run 2025-12-25

si la entrada existe → la reemplaza (update automático)
si no existe → la añade (new)
commit message:
Entrada 2025-12-10 — … (nuevo)
Edición 2025-12-10 — … (modificación)
al final borra scripts/pending_entry.json, pero no toca pending_keywords.txt.:
q 2025-12-10




