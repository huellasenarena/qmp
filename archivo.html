<!-- =========================
  archivo.html – Archivo (por mes)
========================= -->
<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="stylesheet" href="style.css">
  <title>Archivo</title>
  <style>
    .filters {
      display: flex;
      gap: 16px;
      flex-wrap: wrap;
      margin-bottom: 40px;
      font-size: 0.9rem;
    }
    select, input {
      font-family: inherit;
      font-size: 0.9rem;
      padding: 6px 8px;
      border: 1px solid #222;
      background: #fafafa;
    }
    ul {
      list-style: none;
      padding: 0;
      max-width: 650px;
    }
    li {
      margin-bottom: 16px;
    }
    a.entry {
      color: inherit;
      text-decoration: none;
      border-bottom: 1px solid #222;
    }

    #noEntry {
      margin: 6px 0 10px 0;
      font-size: 0.9rem;
      color: #666;
      display: none; /* clave */
    }




    .meta {
      font-size: 0.8rem;
      color: #555;
    }
  </style>
</head>
<body>
  <header>
    <nav>
      <a href="index.html">Poema du jour</a>
      <a href="index.html?a=1">Análisis du jour</a>
      <a href="archivo.html" class="active" >Archivo</a>
      <a href="https://instagram.com/quemalpoema" target="_blank">Instagram</a>
    </nav>
  </header>

  <main>

    <!-- Filtros -->
    <div class="filters">
      <select id="monthFilter">
        <option value="">Mes actual</option>
        <option value="todo">De todos los tiempos</option>
      </select>

      <select id="authorFilter">
        <option value="">Todos los autores</option>
      </select>

      <input type="text" id="keywordFilter" placeholder="Palabras clave" />
    </div>

    <p id="noEntry">No se han encontrado escritos.</p>

    <!-- Lista de escritos -->

    <ul id="entries"></ul>

  </main>

  <script>

    const entriesList = document.getElementById('entries');
    const monthFilter = document.getElementById('monthFilter');
    const authorFilter = document.getElementById('authorFilter');
    const keywordFilter = document.getElementById('keywordFilter');
    const noResultsFound = document.getElementById('noEntry');

    let entries = [];
    const currentMonth = getCurrentMonth();

    fetch('archivo.json')
    .then(res => res.json())
    .then(data => {
        // 1) Crear lista de escritos
      data.forEach(entry => {
        const li = document.createElement('li');

        li.dataset.month = entry.month || '';
        li.dataset.author = entry.analysis?.poet || '';
        const rawKeywords = Array.isArray(entry.keywords) ? entry.keywords : [];
        const kwObjects = rawKeywords
        .map(k => {
          if (typeof k === 'string') return { word: normalize(k), weight: 1 };
          if (k && typeof k === 'object') {
            return {
              word: normalize(String(k.word || '')),
              weight: Number(k.weight || 1)
            };
          }
          return null;
        })
        .filter(k => k && k.word);

        li.dataset.keywords = JSON.stringify(kwObjects); // string

        const poet = entry.analysis?.poet || '';
        const poemTitle = entry.analysis?.poem_title || '';
        const bookTitle = entry.analysis?.book_title || '';

        li.dataset.search = normalize([poet, poemTitle, bookTitle].filter(Boolean).join(' '));

        const a = document.createElement('a');
        a.className = 'entry';
        a.href = `passe.html?date=${entry.date}`;
        a.textContent = formatDate(entry.date);

        li.appendChild(a);
        entriesList.appendChild(li);
      });

        // 2) Poblar filtros (meses y autores) desde JSON
      populateMonthOptions(data);
      populateAuthorOptions(data);

        // 3) Activar filtrado
      entries = document.querySelectorAll('#entries li[data-month]');
      filterEntries();
    })
    .catch(err => {
      console.error(err);
      noResultsFound.style.display = 'block';
      noResultsFound.textContent = 'Error cargando el archivo.';
    });

    function getCurrentMonth() {
      const now = new Date();
      const y = now.getFullYear();
      const m = String(now.getMonth() + 1).padStart(2, '0');
      return `${y}-${m}`;
    }

    function populateMonthOptions(data) {
      const months = Array.from(new Set(data.map(e => e.month).filter(Boolean)))
      .sort()
        .reverse(); // más reciente primero

        months.forEach(ym => {
          const opt = document.createElement('option');
          opt.value = ym;
          opt.textContent = monthLabel(ym);
          monthFilter.appendChild(opt);
        });
      }

      function populateAuthorOptions(data) {
        const authors = Array.from(new Set(
          data.map(e => e.analysis?.poet).filter(Boolean)
          )).sort((a, b) => a.localeCompare(b, 'es'));

        authors.forEach(name => {
          const opt = document.createElement('option');
          opt.value = name;
          opt.textContent = name;
          authorFilter.appendChild(opt);
        });
      }

      function monthLabel(ym) {
        const [y, m] = ym.split('-');
        const months = ['enero','febrero','marzo','abril','mayo','junio','julio','agosto','septiembre','octubre','noviembre','diciembre'];
        return `${months[parseInt(m, 10) - 1]} ${y}`;
      }

      function formatDate(dateStr) {
        const [y, m, d] = dateStr.split('-');
        const months = ['enero','febrero','marzo','abril','mayo','junio','julio','agosto','septiembre','octubre','noviembre','diciembre'];
        return `${parseInt(d, 10)} de ${months[parseInt(m, 10) - 1]} de ${y}`;
      }

      function filterEntries() {
        const month = monthFilter.value;
        const author = authorFilter.value;
        const keyword = normalize(keywordFilter.value.trim());
        let visibleCount = 0;

        const terms = keyword.split(/\s+/).filter(Boolean);

        entries.forEach(entry => {
          const matchMonth =
          month === 'todo' ||
          (!month && entry.dataset.month === currentMonth) ||
          entry.dataset.month === month;

          const matchAuthor = !author || entry.dataset.author === author;
          const score = terms.length === 0 ? 1 : keywordScore(entry, terms);
          const matchKeyword = score > 0;
          entry._score = score;



          const visible = matchMonth && matchAuthor && matchKeyword;
          entry.style.display = visible ? 'block' : 'none';
          if (visible) visibleCount++;
        });

        if (terms.length > 0) {
          const visible = [...entries].filter(e => e.style.display !== 'none');
          visible
          .sort((a, b) => (b._score || 0) - (a._score || 0))
          .forEach(li => entriesList.appendChild(li));
        }

        const hasKeyword = terms.length > 0;
        noResultsFound.style.display = (hasKeyword && visibleCount === 0) ? 'block' : 'none';
      }

    //to normalize, avoid accents etc...
      function normalize(s) {
        return (s || '')
        .toLowerCase()
        .normalize('NFD')
        .replace(/[\u0300-\u036f]/g, '');
      }

      function keywordScore(entry, terms) {
        let score = 0;

        const keywordsArr = JSON.parse(entry.dataset.keywords || '[]');

        for (const t of terms) {
          const match = keywordsArr.find(k => k.word === t);
          if (match) score += match.weight;
        }

        const searchText = entry.dataset.search || '';
        for (const t of terms) {
          if (searchText.includes(t)) score += 0.5;
        }

        return score;
      }


      monthFilter.addEventListener('change', filterEntries);
      authorFilter.addEventListener('change', filterEntries);
      keywordFilter.addEventListener('input', filterEntries);
    </script>
  </body>
  </html>
